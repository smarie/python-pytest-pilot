{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pytest-pilot \u00b6 Slice in your test base thanks to powerful markers In pytest we can create custom markers and filter tests according to them using the -m flag, as explained here . However by default it only supports one kind of marker query behaviour: a test with a mark will run even if you do not use the -m <M> flag. If you wish to implement something more complex, you have to add code in your conftest.py as explained here It is also not easy to understand what happens when a marker has a parameter (an argument) and how to filter according to this. It seems from the examples in the doc that the only way to handle these is again to add code in your conftest.py In other words, it is not easy to expose a \"functional\" view to the user, even if all core mechanisms are perfectly working. pytest-pilot proposes a high-level API to create and register pytest markers so that they are easy to understand and use . To do this it does not use fancy mechanisms: it simply automates most the patterns demonstrated in the pytest documentation. Installing \u00b6 > pip install pytest-pilot Usage \u00b6 1. Basics \u00b6 The easiest way to define a marker is to create an instance of EasyMarker in a conftest.py file . When you create a marker with mymarker = EasyMarker('mymarker', ...) , you get 2 things: @mymarker(arg) is a decorator that is equivalent to @pytest.mark.mymarker(arg) . You can use it to mark some of your tests. For example: @mymarker ( 'red' ) def test_foo (): pass @mymarker ( 'yellow' ) def test_bar (): pass an associated --mymarker CLI option is automatically registered: pytest --mymarker=<arg> or pytest --mymarker <arg> will enable this option. For example >>> pytest --mymarker = red 2. Arguments \u00b6 By default the @mymarker decorator accepts a single argument. The set of allowed arguments can be restricted with allowed_values=... . Alternately EasyMarker can be declared to have no argument and be just a flag ( has_arg=False ). In that case the decorator can be used without parenthesis, and the CLI option will be a flag as well. 3. Names \u00b6 By default the option has just a long name, identical to the marker id. You can customize it and optionally add a short name using cmdoption_long and cmdoption_short . 4. Modes \u00b6 Now all the purpose of this library is to allow you to easily configure which tests should run when this --mymarker CLI option is active, and which ones should run when it is not. This is configured with the mandatory mode argument, with 4 possible values: 'silos' : when the option is inactive , only non-marked tests are run. When the option is active ( pytest --mymarker <arg> ), only tests marked with @mymarker(<arg>) run. There is no test in common between these \"silos\". 'extender' : when the option is inactive , only non-marked tests are run, this is the \"base\" set of tests. When the option is active ( pytest --mymarker <arg> ), it tests marked with @mymarker(<arg>) are added to the base set. 'hard_filter' : when the option is inactive, all tests run. When the option is active, only the relevant marked tests run. 'soft_filter' : when the option is inactive, all tests run. When the option is active, all non-marked tests continue to run, but among marked tests, only the relevant ones run. 5. Examples \u00b6 Silos \u00b6 The silo mode is a way to partition your tests into several, non-intersecting, sets. Unmarked tests are in the \"default\" silo. For example we can create an envid marker defining the python environment on which a test runs. Tests that have this marker should run only if pytest is called with a --envid flag indicating that the environment is active. Tests that do not have this marker are considered in the \"default\" environment and should only run when no environment is set. conftest.py : from pytest_pilot import EasyMarker envid = EasyMarker ( 'envid' , mode = 'silos' ) test_silos.py (you'll have to create an __init__.py in the folder to allow for relative imports): from .conftest import envid @envid ( 'a' ) def test_foo_a (): pass @envid ( 'b' ) def test_foo_b (): pass def test_foo (): pass @envid . agnostic def test_bar (): pass Running pytest (with the -rs option to show a summary of skipped tests) yields: >>> pytest -rs ============================= test session starts ========================================== (...) collected 4 items pytest_pilot/test_doc/test_silos.py::test_foo_a SKIPPED [ 25%] pytest_pilot/test_doc/test_silos.py::test_foo_b SKIPPED [ 50%] pytest_pilot/test_doc/test_silos.py::test_foo PASSED [ 75%] pytest_pilot/test_doc/test_silos.py::test_bar PASSED [100%] ========================== short test summary info ========================================= SKIPPED [1] <file>: This test requires 'envid'='a'. Run `pytest --envid=a` to activate it. SKIPPED [1] <file>: This test requires 'envid'='b'. Run `pytest --envid=b` to activate it. ========================== 2 passed, 2 skipped in 0.04s ==================================== And we can instead activate environment 'b' . >>> pytest -rs --envid=b ============================= test session starts ========================================== (...) collected 4 items pytest_pilot/test_doc/test_silos.py::test_foo_a SKIPPED [ 25%] pytest_pilot/test_doc/test_silos.py::test_foo_b PASSED [ 50%] pytest_pilot/test_doc/test_silos.py::test_foo SKIPPED [ 75%] pytest_pilot/test_doc/test_silos.py::test_bar PASSED [100%] ========================== short test summary info ============================================================= SKIPPED [1] <file>: This test requires 'envid'='a'. Currently `--envid=b` so it is skipped. SKIPPED [1] <file>: This test does not have mark 'envid', and pytest was run with `--envid=b` so it is skipped ========================== 2 passed, 2 skipped in 0.04s ======================================================== Note that as can be seen above, test_foo , that was not marked, is now skipped (it is implicitly in the \"no env\" silo so if we activate another silo it becomes skipped). Only tests explicitly marked as agnostic (in this example test_bar ) are allowed to run whatever the silo. This is the main difference with the \"extender\" mode below . Extender \u00b6 The extender mode is probably the simplest to understand: marked tests are optional tests, that can be added to the other tests when the option is specified. For example let's mark a few tests as being slow tests that should be skipped for daily testing. Note that this time we'll create a marker with no arguments to show that such markers can also be created, but it could of course receive arguments just as in previous example. conftest.py : from pytest_pilot import EasyMarker slow = EasyMarker ( 'slow' , has_arg = False , mode = 'extender' ) test_extender.py : from .conftest import slow @slow def test_bar_slow (): pass def test_bar (): pass Running pytest (with the -rs option to show a summary of skipped tests) yields: >>> pytest -rs ============================= test session starts ========================================== (...) collected 2 items pytest_pilot/test_doc/test_extender.py::test_bar_slow SKIPPED [ 50%] pytest_pilot/test_doc/test_extender.py::test_foo PASSED [100%] ========================== short test summary info ========================================= SKIPPED [1] <file>: This test requires 'slow'. Run `pytest --slow` to activate it. ========================== 1 passed, 1 skipped in 0.04s ==================================== And we can run all tests including the slow ones with --slow : >>> pytest -rs --slow ============================= test session starts ========================================== (...) collected 2 items pytest_pilot/test_doc/test_extender.py::test_bar_slow PASSED [ 50%] pytest_pilot/test_doc/test_extender.py::test_foo PASSED [100%] ================================ 2 passed in 0.04s ========================================= Hard filter \u00b6 \"Hard filter\" mode is the opposite of \"Extender\". Instead of adding tests when the option is active, it removes all irrelevant tests, keeping only those matching the query. conftest.py : from pytest_pilot import EasyMarker # below we demonstrate the usage of `allowed_values` to restrict the possible values flavour = EasyMarker ( 'flavour' , allowed_values = ( 'red' , 'yellow' ), mode = 'hard_filter' ) test_hardfilter.py (you'll have to create an __init__.py in the folder to allow for relative imports): from .conftest import flavour @flavour ( 'yellow' ) def test_foo_yellow (): pass @flavour ( 'red' ) def test_foo_red (): pass def test_foo (): pass @flavour . agnostic def test_bar (): pass Running pytest (with the -rs option to show a summary of skipped tests) yields: >>> pytest -rs ============================= test session starts ========================================== (...) collected 4 items pytest_pilot/test_doc/test_hardfilter.py::test_foo_yellow PASSED [ 25%] pytest_pilot/test_doc/test_hardfilter.py::test_foo_red PASSED [ 50%] pytest_pilot/test_doc/test_hardfilter.py::test_foo PASSED [ 75%] pytest_pilot/test_doc/test_hardfilter.py::test_bar PASSED [100%] ================================ 4 passed in 0.04s ========================================= We can instead filter on tests with the 'red' flavour: >>> pytest -rs --flavour=red ============================= test session starts ========================================== (...) collected 4 items pytest_pilot/test_doc/test_hardfilter.py::test_foo_yellow SKIPPED [ 25%] pytest_pilot/test_doc/test_hardfilter.py::test_foo_red PASSED [ 50%] pytest_pilot/test_doc/test_hardfilter.py::test_foo SKIPPED [ 75%] pytest_pilot/test_doc/test_hardfilter.py::test_bar PASSED [100%] ========================== short test summary info ============================================================= SKIPPED [1] <file>: This test requires 'flavour'='yellow'. Currently `--flavour=red` so it is skipped. SKIPPED [1] <file>: This test does not have mark 'flavour', and pytest was run with `--flavour=red` so it is skipped. ========================== 2 passed, 2 skipped in 0.04s ======================================================== You can see that test_foo , that was not marked, has been skipped, while test_bar , that was explicitly marked as agnostic , continues to run. This is the main difference with the soft filer presented below. Soft filter \u00b6 \"Soft filter\" mode is very similar to \"Hard filter\". The only difference is for non-marked tests. While in hard filter mode they are skipped as soon as the option is active, in soft filter mode they are always run. conftest.py : from pytest_pilot import EasyMarker flavour = EasyMarker ( 'flavour' , allowed_values = ( 'red' , 'yellow' ), mode = 'soft_filter' ) test_hardfilter.py (you'll have to create an __init__.py in the folder to allow for relative imports): from .conftest import flavour @flavour ( 'yellow' ) def test_foo_yellow (): pass @flavour ( 'red' ) def test_foo_red (): pass def test_foo (): pass Running pytest (with the -rs option to show a summary of skipped tests) yields: >>> pytest -rs ============================= test session starts ========================================== (...) collected 3 items pytest_pilot/test_doc/test_hardfilter.py::test_foo_yellow PASSED [ 33%] pytest_pilot/test_doc/test_hardfilter.py::test_foo_red PASSED [ 66%] pytest_pilot/test_doc/test_hardfilter.py::test_foo PASSED [100%] ================================ 3 passed in 0.04s ========================================= We can instead filter on tests with the 'yellow' flavour: >>> pytest -rs --flavour=yellow ============================= test session starts ========================================== (...) collected 3 items pytest_pilot/test_doc/test_hardfilter.py::test_foo_yellow PASSED [ 33%] pytest_pilot/test_doc/test_hardfilter.py::test_foo_red SKIPPED [ 66%] pytest_pilot/test_doc/test_hardfilter.py::test_foo PASSED [100%] ========================== short test summary info ============================================================= SKIPPED [1] <file>: This test requires 'flavour'='red'. Currently `--flavour=yellow` so it is skipped. ========================== 2 passed, 1 skipped in 0.04s ======================================================== You can see that now test_foo , that was not marked, was not skipped - as opposed to the previous example of \"hard filter\". 7. Misc \u00b6 Knowing the value of the command options inside a test \u00b6 There are two ways to know the value of an option associated to a marker, from within a test. either you can use the usual pytest API to get the config object, and from there do config.getoption(<marker_option_name>) where you can programmatically fill <marker_option_name> from marker.cmdoption_long[2:] . or you can simply use the easymarkers fixture. This object has one attribute per EasyMarker and the attribute values correspond to the corresponding commandline option value: def test_foo ( easymarkers ): # see the value of all marker related options at once print ( easymarkers ) # see the value of the --envid option print ( easymarkers . envid ) Using the markers in parametrized tests \u00b6 If your tests are parametrized, you can use the markers on individual parametrization value: either using the traditional pytest.param(<argvalues>, marks=<marker>) either using the provided convenience method <marker>.param(<argvalues>) As shown below: @pytest . mark . parametrize ( \"a\" , [ pytest . param ( - 1 , marks = slow ), 0 , pytest . param ( False , marks = envid ( \"win\" )), slow . param ( True ), 1 , envid ( \"win\" ) . param ( 2 ) ]) def test_foo ( a ): pass Further customization \u00b6 See API reference for details. Debug / Verbosity levels \u00b6 You can use the verbose pytest flags with the -s option to get a little more explanation about why tests are skipped or why they are NOT skipped (while you think they should): >>> pytest -s -vv --flavour = red ( verbose explanations ) >>> pytest -s -vvv --flavour = red ( even more verbose explanations ) Help \u00b6 Help on command options is automatically added to the pytest --help output: >>> pytest --help ( ... ) custom options: --flavour = NAME run tests marked as requiring flavour NAME ( marked with @flavour ( NAME )) , as well as tests not marked with @flavour. If you call ` pytest ` without this option, tests marked with @flavour will *all* be run. ( ... ) Help on markers is automatically added to the pytest --markers output: >>> pytest --markers ( ... ) @pytest.mark.flavour ( value ) : mark test to run *both* when --flavour ( 'flavour' option ) is set to <value> and if --flavour is not set. <value> should be one of ( 'red' , 'yellow' ) . ( ... ) Main features / benefits \u00b6 Create intuitive markers in minutes, with consistent behaviour and associated command options, documented with user-friendly help. See Also \u00b6 pytest tutorial on working with custom markers this excellent explanation about how to add options so as to filter on custom markers or on parameter names and values pytest hooks Others \u00b6 Do you like this library ? You might also like my other python libraries Want to contribute ? \u00b6 Details on the github page: https://github.com/smarie/python-pytest-pilot","title":"Home"},{"location":"#pytest-pilot","text":"Slice in your test base thanks to powerful markers In pytest we can create custom markers and filter tests according to them using the -m flag, as explained here . However by default it only supports one kind of marker query behaviour: a test with a mark will run even if you do not use the -m <M> flag. If you wish to implement something more complex, you have to add code in your conftest.py as explained here It is also not easy to understand what happens when a marker has a parameter (an argument) and how to filter according to this. It seems from the examples in the doc that the only way to handle these is again to add code in your conftest.py In other words, it is not easy to expose a \"functional\" view to the user, even if all core mechanisms are perfectly working. pytest-pilot proposes a high-level API to create and register pytest markers so that they are easy to understand and use . To do this it does not use fancy mechanisms: it simply automates most the patterns demonstrated in the pytest documentation.","title":"pytest-pilot"},{"location":"#installing","text":"> pip install pytest-pilot","title":"Installing"},{"location":"#usage","text":"","title":"Usage"},{"location":"#1-basics","text":"The easiest way to define a marker is to create an instance of EasyMarker in a conftest.py file . When you create a marker with mymarker = EasyMarker('mymarker', ...) , you get 2 things: @mymarker(arg) is a decorator that is equivalent to @pytest.mark.mymarker(arg) . You can use it to mark some of your tests. For example: @mymarker ( 'red' ) def test_foo (): pass @mymarker ( 'yellow' ) def test_bar (): pass an associated --mymarker CLI option is automatically registered: pytest --mymarker=<arg> or pytest --mymarker <arg> will enable this option. For example >>> pytest --mymarker = red","title":"1. Basics"},{"location":"#2-arguments","text":"By default the @mymarker decorator accepts a single argument. The set of allowed arguments can be restricted with allowed_values=... . Alternately EasyMarker can be declared to have no argument and be just a flag ( has_arg=False ). In that case the decorator can be used without parenthesis, and the CLI option will be a flag as well.","title":"2. Arguments"},{"location":"#3-names","text":"By default the option has just a long name, identical to the marker id. You can customize it and optionally add a short name using cmdoption_long and cmdoption_short .","title":"3. Names"},{"location":"#4-modes","text":"Now all the purpose of this library is to allow you to easily configure which tests should run when this --mymarker CLI option is active, and which ones should run when it is not. This is configured with the mandatory mode argument, with 4 possible values: 'silos' : when the option is inactive , only non-marked tests are run. When the option is active ( pytest --mymarker <arg> ), only tests marked with @mymarker(<arg>) run. There is no test in common between these \"silos\". 'extender' : when the option is inactive , only non-marked tests are run, this is the \"base\" set of tests. When the option is active ( pytest --mymarker <arg> ), it tests marked with @mymarker(<arg>) are added to the base set. 'hard_filter' : when the option is inactive, all tests run. When the option is active, only the relevant marked tests run. 'soft_filter' : when the option is inactive, all tests run. When the option is active, all non-marked tests continue to run, but among marked tests, only the relevant ones run.","title":"4. Modes"},{"location":"#5-examples","text":"","title":"5. Examples"},{"location":"#silos","text":"The silo mode is a way to partition your tests into several, non-intersecting, sets. Unmarked tests are in the \"default\" silo. For example we can create an envid marker defining the python environment on which a test runs. Tests that have this marker should run only if pytest is called with a --envid flag indicating that the environment is active. Tests that do not have this marker are considered in the \"default\" environment and should only run when no environment is set. conftest.py : from pytest_pilot import EasyMarker envid = EasyMarker ( 'envid' , mode = 'silos' ) test_silos.py (you'll have to create an __init__.py in the folder to allow for relative imports): from .conftest import envid @envid ( 'a' ) def test_foo_a (): pass @envid ( 'b' ) def test_foo_b (): pass def test_foo (): pass @envid . agnostic def test_bar (): pass Running pytest (with the -rs option to show a summary of skipped tests) yields: >>> pytest -rs ============================= test session starts ========================================== (...) collected 4 items pytest_pilot/test_doc/test_silos.py::test_foo_a SKIPPED [ 25%] pytest_pilot/test_doc/test_silos.py::test_foo_b SKIPPED [ 50%] pytest_pilot/test_doc/test_silos.py::test_foo PASSED [ 75%] pytest_pilot/test_doc/test_silos.py::test_bar PASSED [100%] ========================== short test summary info ========================================= SKIPPED [1] <file>: This test requires 'envid'='a'. Run `pytest --envid=a` to activate it. SKIPPED [1] <file>: This test requires 'envid'='b'. Run `pytest --envid=b` to activate it. ========================== 2 passed, 2 skipped in 0.04s ==================================== And we can instead activate environment 'b' . >>> pytest -rs --envid=b ============================= test session starts ========================================== (...) collected 4 items pytest_pilot/test_doc/test_silos.py::test_foo_a SKIPPED [ 25%] pytest_pilot/test_doc/test_silos.py::test_foo_b PASSED [ 50%] pytest_pilot/test_doc/test_silos.py::test_foo SKIPPED [ 75%] pytest_pilot/test_doc/test_silos.py::test_bar PASSED [100%] ========================== short test summary info ============================================================= SKIPPED [1] <file>: This test requires 'envid'='a'. Currently `--envid=b` so it is skipped. SKIPPED [1] <file>: This test does not have mark 'envid', and pytest was run with `--envid=b` so it is skipped ========================== 2 passed, 2 skipped in 0.04s ======================================================== Note that as can be seen above, test_foo , that was not marked, is now skipped (it is implicitly in the \"no env\" silo so if we activate another silo it becomes skipped). Only tests explicitly marked as agnostic (in this example test_bar ) are allowed to run whatever the silo. This is the main difference with the \"extender\" mode below .","title":"Silos"},{"location":"#extender","text":"The extender mode is probably the simplest to understand: marked tests are optional tests, that can be added to the other tests when the option is specified. For example let's mark a few tests as being slow tests that should be skipped for daily testing. Note that this time we'll create a marker with no arguments to show that such markers can also be created, but it could of course receive arguments just as in previous example. conftest.py : from pytest_pilot import EasyMarker slow = EasyMarker ( 'slow' , has_arg = False , mode = 'extender' ) test_extender.py : from .conftest import slow @slow def test_bar_slow (): pass def test_bar (): pass Running pytest (with the -rs option to show a summary of skipped tests) yields: >>> pytest -rs ============================= test session starts ========================================== (...) collected 2 items pytest_pilot/test_doc/test_extender.py::test_bar_slow SKIPPED [ 50%] pytest_pilot/test_doc/test_extender.py::test_foo PASSED [100%] ========================== short test summary info ========================================= SKIPPED [1] <file>: This test requires 'slow'. Run `pytest --slow` to activate it. ========================== 1 passed, 1 skipped in 0.04s ==================================== And we can run all tests including the slow ones with --slow : >>> pytest -rs --slow ============================= test session starts ========================================== (...) collected 2 items pytest_pilot/test_doc/test_extender.py::test_bar_slow PASSED [ 50%] pytest_pilot/test_doc/test_extender.py::test_foo PASSED [100%] ================================ 2 passed in 0.04s =========================================","title":"Extender"},{"location":"#hard-filter","text":"\"Hard filter\" mode is the opposite of \"Extender\". Instead of adding tests when the option is active, it removes all irrelevant tests, keeping only those matching the query. conftest.py : from pytest_pilot import EasyMarker # below we demonstrate the usage of `allowed_values` to restrict the possible values flavour = EasyMarker ( 'flavour' , allowed_values = ( 'red' , 'yellow' ), mode = 'hard_filter' ) test_hardfilter.py (you'll have to create an __init__.py in the folder to allow for relative imports): from .conftest import flavour @flavour ( 'yellow' ) def test_foo_yellow (): pass @flavour ( 'red' ) def test_foo_red (): pass def test_foo (): pass @flavour . agnostic def test_bar (): pass Running pytest (with the -rs option to show a summary of skipped tests) yields: >>> pytest -rs ============================= test session starts ========================================== (...) collected 4 items pytest_pilot/test_doc/test_hardfilter.py::test_foo_yellow PASSED [ 25%] pytest_pilot/test_doc/test_hardfilter.py::test_foo_red PASSED [ 50%] pytest_pilot/test_doc/test_hardfilter.py::test_foo PASSED [ 75%] pytest_pilot/test_doc/test_hardfilter.py::test_bar PASSED [100%] ================================ 4 passed in 0.04s ========================================= We can instead filter on tests with the 'red' flavour: >>> pytest -rs --flavour=red ============================= test session starts ========================================== (...) collected 4 items pytest_pilot/test_doc/test_hardfilter.py::test_foo_yellow SKIPPED [ 25%] pytest_pilot/test_doc/test_hardfilter.py::test_foo_red PASSED [ 50%] pytest_pilot/test_doc/test_hardfilter.py::test_foo SKIPPED [ 75%] pytest_pilot/test_doc/test_hardfilter.py::test_bar PASSED [100%] ========================== short test summary info ============================================================= SKIPPED [1] <file>: This test requires 'flavour'='yellow'. Currently `--flavour=red` so it is skipped. SKIPPED [1] <file>: This test does not have mark 'flavour', and pytest was run with `--flavour=red` so it is skipped. ========================== 2 passed, 2 skipped in 0.04s ======================================================== You can see that test_foo , that was not marked, has been skipped, while test_bar , that was explicitly marked as agnostic , continues to run. This is the main difference with the soft filer presented below.","title":"Hard filter"},{"location":"#soft-filter","text":"\"Soft filter\" mode is very similar to \"Hard filter\". The only difference is for non-marked tests. While in hard filter mode they are skipped as soon as the option is active, in soft filter mode they are always run. conftest.py : from pytest_pilot import EasyMarker flavour = EasyMarker ( 'flavour' , allowed_values = ( 'red' , 'yellow' ), mode = 'soft_filter' ) test_hardfilter.py (you'll have to create an __init__.py in the folder to allow for relative imports): from .conftest import flavour @flavour ( 'yellow' ) def test_foo_yellow (): pass @flavour ( 'red' ) def test_foo_red (): pass def test_foo (): pass Running pytest (with the -rs option to show a summary of skipped tests) yields: >>> pytest -rs ============================= test session starts ========================================== (...) collected 3 items pytest_pilot/test_doc/test_hardfilter.py::test_foo_yellow PASSED [ 33%] pytest_pilot/test_doc/test_hardfilter.py::test_foo_red PASSED [ 66%] pytest_pilot/test_doc/test_hardfilter.py::test_foo PASSED [100%] ================================ 3 passed in 0.04s ========================================= We can instead filter on tests with the 'yellow' flavour: >>> pytest -rs --flavour=yellow ============================= test session starts ========================================== (...) collected 3 items pytest_pilot/test_doc/test_hardfilter.py::test_foo_yellow PASSED [ 33%] pytest_pilot/test_doc/test_hardfilter.py::test_foo_red SKIPPED [ 66%] pytest_pilot/test_doc/test_hardfilter.py::test_foo PASSED [100%] ========================== short test summary info ============================================================= SKIPPED [1] <file>: This test requires 'flavour'='red'. Currently `--flavour=yellow` so it is skipped. ========================== 2 passed, 1 skipped in 0.04s ======================================================== You can see that now test_foo , that was not marked, was not skipped - as opposed to the previous example of \"hard filter\".","title":"Soft filter"},{"location":"#7-misc","text":"","title":"7. Misc"},{"location":"#knowing-the-value-of-the-command-options-inside-a-test","text":"There are two ways to know the value of an option associated to a marker, from within a test. either you can use the usual pytest API to get the config object, and from there do config.getoption(<marker_option_name>) where you can programmatically fill <marker_option_name> from marker.cmdoption_long[2:] . or you can simply use the easymarkers fixture. This object has one attribute per EasyMarker and the attribute values correspond to the corresponding commandline option value: def test_foo ( easymarkers ): # see the value of all marker related options at once print ( easymarkers ) # see the value of the --envid option print ( easymarkers . envid )","title":"Knowing the value of the command options inside a test"},{"location":"#using-the-markers-in-parametrized-tests","text":"If your tests are parametrized, you can use the markers on individual parametrization value: either using the traditional pytest.param(<argvalues>, marks=<marker>) either using the provided convenience method <marker>.param(<argvalues>) As shown below: @pytest . mark . parametrize ( \"a\" , [ pytest . param ( - 1 , marks = slow ), 0 , pytest . param ( False , marks = envid ( \"win\" )), slow . param ( True ), 1 , envid ( \"win\" ) . param ( 2 ) ]) def test_foo ( a ): pass","title":"Using the markers in parametrized tests"},{"location":"#further-customization","text":"See API reference for details.","title":"Further customization"},{"location":"#debug-verbosity-levels","text":"You can use the verbose pytest flags with the -s option to get a little more explanation about why tests are skipped or why they are NOT skipped (while you think they should): >>> pytest -s -vv --flavour = red ( verbose explanations ) >>> pytest -s -vvv --flavour = red ( even more verbose explanations )","title":"Debug / Verbosity levels"},{"location":"#help","text":"Help on command options is automatically added to the pytest --help output: >>> pytest --help ( ... ) custom options: --flavour = NAME run tests marked as requiring flavour NAME ( marked with @flavour ( NAME )) , as well as tests not marked with @flavour. If you call ` pytest ` without this option, tests marked with @flavour will *all* be run. ( ... ) Help on markers is automatically added to the pytest --markers output: >>> pytest --markers ( ... ) @pytest.mark.flavour ( value ) : mark test to run *both* when --flavour ( 'flavour' option ) is set to <value> and if --flavour is not set. <value> should be one of ( 'red' , 'yellow' ) . ( ... )","title":"Help"},{"location":"#main-features-benefits","text":"Create intuitive markers in minutes, with consistent behaviour and associated command options, documented with user-friendly help.","title":"Main features / benefits"},{"location":"#see-also","text":"pytest tutorial on working with custom markers this excellent explanation about how to add options so as to filter on custom markers or on parameter names and values pytest hooks","title":"See Also"},{"location":"#others","text":"Do you like this library ? You might also like my other python libraries","title":"Others"},{"location":"#want-to-contribute","text":"Details on the github page: https://github.com/smarie/python-pytest-pilot","title":"Want to contribute ?"},{"location":"api_reference/","text":"API reference \u00b6 In general, using help(symbol) is the recommended way to get the latest documentation. In addition, this page provides an overview of the various elements in this package. EasyMarker \u00b6 A helper class to create pytest marks. EasyMarker ( marker_id , # type: str mode , # type: str full_name = None , # type: str has_arg = True , # type: bool allowed_values = None , # type: Iterable[Any] cmdoption_short = None , # type: str cmdoption_long = None , # type: str cmdhelp = None , # type: str markhelp = None , # type: str ) Creates a pair of marker + commandline option for pytest. Marker instances can be used to decorate test classes or test functions: @marker or @marker(arg) depending whether you set has_arg=False/True in parametrization values with pytest.param(*<argvalues>, marks=<self>) or pytest.param(*<argvalues>, marks=<self>(arg)) (for this, we inherit from MarkDecorator and override .mark) In addition, <self>.param(*<argvalues>) or <self>(arg).param(*<argvalues>) is a convenience method provided to do the same than pytest.param(*<argvalues>, marks=<self>) or pytest.param(*<argvalues>, marks=<self>(arg)) . A special decorator @<marker>.agnostic can be used to decorate tests that should always run, whatever the configuration. This is only relevant for mode='silos' or mode='hard_filter' , see below. Parameters: marker_id : the name of the pytest mark. Applying this marker with @marker(arg) will be equivalent to applying @pytest.mark. (arg) mode : a mandatory string indicating the working mode of this mark and the associated filter option. Four modes are supported: 'silos': When the option is inactive, only non-marked tests are run. When the option is active, only relevant marked tests run. There is no test in common between these \"silos\" 'extender': When the option is inactive, only non-marked tests are run, this is the \"base\" set of tests. When the option is active, it adds the relevant marked tests to the base set. 'hard_filter': When the option is inactive, all tests run. When the option is active, only the relevant marked tests run. 'soft_filter': When the option is inactive, all tests run. When the option is active, all non-marked tests continue to run, but among marked tests only the relevant ones run. full_name : the full name of the marker, to be used in help texts. If None (default), it defaults to marker_id . has_arg : if this is True (default), the marker has a single argument and the filtering commandline option accepts an argument too. For example a colormarker with id color will accept an argument describing which color: @colormarker('yellow') . If this is False , the marker has no argument and the filtering commandline option is a flag with no arguments too. For example a smokemarker with id smoke : @smokemarker . allowed_values : a predefined set of values that can be used for this marker. Applying the mark with another value as argument will result in a ValueError being raised. None (default) will allow users to apply this mark with any value. Note that this can only be set if has_arg is True cmdoption_short : the id to use for the \"short\" command option (for example providing 'E' or '-E' will result in the option '-E' ). None (default) will not create a \"short\" command option, to avoid name collisions. cmdoption_long : the id to use for the \"long\" command option (for example providing 'env' or '--env' will result in the option '--env' ). None (default) will use marker_id for the long command option. cmdhelp : the help message displayed when pytest --help is called markhelp : the help message displayed when pytest --markers is called easymarkers fixture \u00b6 A fixture containing all EasyMarker related CLI option current values You can list all key-value pairs with vars(easymarkers) and access each value using attribute access: easymarkers.<option> .","title":"API reference"},{"location":"api_reference/#api-reference","text":"In general, using help(symbol) is the recommended way to get the latest documentation. In addition, this page provides an overview of the various elements in this package.","title":"API reference"},{"location":"api_reference/#easymarker","text":"A helper class to create pytest marks. EasyMarker ( marker_id , # type: str mode , # type: str full_name = None , # type: str has_arg = True , # type: bool allowed_values = None , # type: Iterable[Any] cmdoption_short = None , # type: str cmdoption_long = None , # type: str cmdhelp = None , # type: str markhelp = None , # type: str ) Creates a pair of marker + commandline option for pytest. Marker instances can be used to decorate test classes or test functions: @marker or @marker(arg) depending whether you set has_arg=False/True in parametrization values with pytest.param(*<argvalues>, marks=<self>) or pytest.param(*<argvalues>, marks=<self>(arg)) (for this, we inherit from MarkDecorator and override .mark) In addition, <self>.param(*<argvalues>) or <self>(arg).param(*<argvalues>) is a convenience method provided to do the same than pytest.param(*<argvalues>, marks=<self>) or pytest.param(*<argvalues>, marks=<self>(arg)) . A special decorator @<marker>.agnostic can be used to decorate tests that should always run, whatever the configuration. This is only relevant for mode='silos' or mode='hard_filter' , see below. Parameters: marker_id : the name of the pytest mark. Applying this marker with @marker(arg) will be equivalent to applying @pytest.mark. (arg) mode : a mandatory string indicating the working mode of this mark and the associated filter option. Four modes are supported: 'silos': When the option is inactive, only non-marked tests are run. When the option is active, only relevant marked tests run. There is no test in common between these \"silos\" 'extender': When the option is inactive, only non-marked tests are run, this is the \"base\" set of tests. When the option is active, it adds the relevant marked tests to the base set. 'hard_filter': When the option is inactive, all tests run. When the option is active, only the relevant marked tests run. 'soft_filter': When the option is inactive, all tests run. When the option is active, all non-marked tests continue to run, but among marked tests only the relevant ones run. full_name : the full name of the marker, to be used in help texts. If None (default), it defaults to marker_id . has_arg : if this is True (default), the marker has a single argument and the filtering commandline option accepts an argument too. For example a colormarker with id color will accept an argument describing which color: @colormarker('yellow') . If this is False , the marker has no argument and the filtering commandline option is a flag with no arguments too. For example a smokemarker with id smoke : @smokemarker . allowed_values : a predefined set of values that can be used for this marker. Applying the mark with another value as argument will result in a ValueError being raised. None (default) will allow users to apply this mark with any value. Note that this can only be set if has_arg is True cmdoption_short : the id to use for the \"short\" command option (for example providing 'E' or '-E' will result in the option '-E' ). None (default) will not create a \"short\" command option, to avoid name collisions. cmdoption_long : the id to use for the \"long\" command option (for example providing 'env' or '--env' will result in the option '--env' ). None (default) will use marker_id for the long command option. cmdhelp : the help message displayed when pytest --help is called markhelp : the help message displayed when pytest --markers is called","title":"EasyMarker"},{"location":"api_reference/#easymarkers-fixture","text":"A fixture containing all EasyMarker related CLI option current values You can list all key-value pairs with vars(easymarkers) and access each value using attribute access: easymarkers.<option> .","title":"easymarkers fixture"},{"location":"changelog/","text":"Changelog \u00b6 0.8.0 - New easymarkers fixture \u00b6 New easymarkers fixture to access current values of all CLI options related to EasyMarkers, from within tests. Fixed #17 0.7.0 - New agnostic mark \u00b6 @<marker>.agnostic can be used to decorate tests that should always run, whatever the configuration. This is only relevant for mode='silos' or mode='hard_filter' . Fixes #15 0.6.0 - Usage in parametrization \u00b6 EasyMarker markers can now be used on parameters in tests (and also on case functions, if you use pytest-cases :)). Fixes #12 0.5.0 - Better API, implementation and documentation \u00b6 EasyMarker API improvements: now a single mode argument with four supported values ( 'silos' , 'extender' , hard_filter , soft_filter ) replaces the very unfriendly filtering_skips_unmarked and not_filtering_skips_marked . This argument is mandatory, so that users have to decide what they want as a resulting behaviour. Fixes #5 Markers without arguments ( EasyMarker(has_arg=False) ) now work correctly. Fixes #8 Short command option name ( EasyMarker(cmdoption_short=...) ) is now registered correctly. Fixed #9 allowed_values are now correctly taken into account by EasyMarker . Fixes #1 Removed annoying warning about marks registration. Fixes #6 Improved the various messages printed when using pytest --markers and pytest --help . In particular, using --markers shows the allowed values for a given marker. 0.1.2 - packaging improvements \u00b6 packaging improvements: set the \"universal wheel\" flag to 1, and cleaned up the setup.py . In particular removed dependency to six for setup and added py.typed file, as well as set the zip_safe flag to False. Removed tests folder from package. Fixes #4 0.1.1 - pyproject.toml \u00b6 Added pyproject.toml 0.1.0 - First public version \u00b6 Initial fork from private repository","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#080-new-easymarkers-fixture","text":"New easymarkers fixture to access current values of all CLI options related to EasyMarkers, from within tests. Fixed #17","title":"0.8.0 - New easymarkers fixture"},{"location":"changelog/#070-new-agnostic-mark","text":"@<marker>.agnostic can be used to decorate tests that should always run, whatever the configuration. This is only relevant for mode='silos' or mode='hard_filter' . Fixes #15","title":"0.7.0 - New agnostic mark"},{"location":"changelog/#060-usage-in-parametrization","text":"EasyMarker markers can now be used on parameters in tests (and also on case functions, if you use pytest-cases :)). Fixes #12","title":"0.6.0 - Usage in parametrization"},{"location":"changelog/#050-better-api-implementation-and-documentation","text":"EasyMarker API improvements: now a single mode argument with four supported values ( 'silos' , 'extender' , hard_filter , soft_filter ) replaces the very unfriendly filtering_skips_unmarked and not_filtering_skips_marked . This argument is mandatory, so that users have to decide what they want as a resulting behaviour. Fixes #5 Markers without arguments ( EasyMarker(has_arg=False) ) now work correctly. Fixes #8 Short command option name ( EasyMarker(cmdoption_short=...) ) is now registered correctly. Fixed #9 allowed_values are now correctly taken into account by EasyMarker . Fixes #1 Removed annoying warning about marks registration. Fixes #6 Improved the various messages printed when using pytest --markers and pytest --help . In particular, using --markers shows the allowed values for a given marker.","title":"0.5.0 - Better API, implementation and documentation"},{"location":"changelog/#012-packaging-improvements","text":"packaging improvements: set the \"universal wheel\" flag to 1, and cleaned up the setup.py . In particular removed dependency to six for setup and added py.typed file, as well as set the zip_safe flag to False. Removed tests folder from package. Fixes #4","title":"0.1.2 - packaging improvements"},{"location":"changelog/#011-pyprojecttoml","text":"Added pyproject.toml","title":"0.1.1 - pyproject.toml"},{"location":"changelog/#010-first-public-version","text":"Initial fork from private repository","title":"0.1.0 - First public version"},{"location":"long_description/","text":"pytest-pilot \u00b6 Slice in your test base thanks to powerful markers The documentation for users is available here: https://smarie.github.io/python-pytest-pilot/ A readme for developers is available here: https://github.com/smarie/python-pytest-pilot","title":"pytest-pilot"},{"location":"long_description/#pytest-pilot","text":"Slice in your test base thanks to powerful markers The documentation for users is available here: https://smarie.github.io/python-pytest-pilot/ A readme for developers is available here: https://github.com/smarie/python-pytest-pilot","title":"pytest-pilot"}]}