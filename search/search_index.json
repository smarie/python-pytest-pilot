{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pytest-pilot","text":"<p>Slice in your test base thanks to powerful markers</p> <p> </p> <p> </p> <p>Success</p> <p>\"Starting in <code>0.9.0</code>, tests are deselected instead of being skipped - leading to huge performance gains  on large test codebases. Legacy behaviour can be set back with <code>--pilot-skip</code>, see  below.\"</p> <p>In <code>pytest</code> we can create custom markers and filter tests according to them using the <code>-m</code> flag, as explained here. However </p> <ul> <li> <p>by default it only supports one kind of marker query behaviour: a test with a mark  will run even if you do not use the <code>-m &lt;M&gt;</code> flag. If you wish to implement something more complex, you have to add code in your <code>conftest.py</code> as explained here <li> <p>It is also not easy to understand what happens when a marker has a parameter (an argument) and how to filter according to this. It seems from the examples in the doc that the only way to handle these is again to add code in your <code>conftest.py</code></p> </li> <li> <p>In other words, it is not easy to expose a \"functional\" view to the user, even if all core mechanisms are perfectly working.</p> </li> <p><code>pytest-pilot</code> proposes a high-level API to create and register pytest markers so that they are easy to understand and use. To do this it does not use fancy mechanisms: it simply automates most the patterns demonstrated in the <code>pytest</code> documentation. </p>"},{"location":"#installing","title":"Installing","text":"<pre><code>&gt; pip install pytest-pilot\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#1-basics","title":"1. Basics","text":"<p>The easiest way to define a marker is to create an instance of <code>EasyMarker</code> in a <code>conftest.py</code> file. </p> <p>When you create a marker with <code>mymarker = EasyMarker('mymarker', ...)</code>, you get 2 things:</p> <ul> <li><code>@mymarker(arg)</code> is a decorator that is equivalent to <code>@pytest.mark.mymarker(arg)</code>. You can use it to mark some of your tests. For example:</li> </ul> <pre><code>@mymarker('red')\ndef test_foo():\n    pass\n\n@mymarker('yellow')\ndef test_bar():\n    pass\n</code></pre> <ul> <li>an associated <code>--mymarker</code> CLI option is automatically registered: <code>pytest --mymarker=&lt;arg&gt;</code> or <code>pytest --mymarker &lt;arg&gt;</code> will enable this option. For example</li> </ul> <pre><code>&gt;&gt;&gt; pytest --mymarker=red\n</code></pre>"},{"location":"#2-arguments","title":"2. Arguments","text":"<p>By default the <code>@mymarker</code> decorator accepts a single argument. The set of allowed arguments can be restricted with <code>allowed_values=...</code>. Alternately <code>EasyMarker</code> can be declared to have no argument and be just a flag (<code>has_arg=False</code>). In that case the decorator can be used without parenthesis, and the CLI option will be a flag as well.</p>"},{"location":"#3-names","title":"3. Names","text":"<p>By default the option has just a long name, identical to the marker id. You can customize it and optionally add a short name using <code>cmdoption_long</code> and <code>cmdoption_short</code>.</p>"},{"location":"#4-modes","title":"4. Modes","text":"<p>Now all the purpose of this library is to allow you to easily configure which tests should run when this <code>--mymarker</code> CLI option is active, and which ones should run when it is not. This is configured with the mandatory <code>mode</code> argument, with 4 possible values:</p> <ul> <li> <p><code>'silos'</code>: when the option is inactive, only non-marked tests are run. When the option is active (<code>pytest --mymarker &lt;arg&gt;</code>), only tests marked with <code>@mymarker(&lt;arg&gt;)</code> run. There is no test in common between these \"silos\".</p> </li> <li> <p><code>'extender'</code>: when the option is inactive, only non-marked tests are run, this is the \"base\" set of tests. When the option is active (<code>pytest --mymarker &lt;arg&gt;</code>), it tests marked with <code>@mymarker(&lt;arg&gt;)</code> are added to the base set.</p> </li> <li> <p><code>'hard_filter'</code>: when the option is inactive, all tests run. When the option is active, only the relevant marked tests run.</p> </li> <li> <p><code>'soft_filter'</code>: when the option is inactive, all tests run. When the option is active, all non-marked tests continue to run, but among marked tests, only the relevant ones run. </p> </li> </ul>"},{"location":"#5-examples","title":"5. Examples","text":""},{"location":"#silos","title":"Silos","text":"<p>The silo mode is a way to partition your tests into several, non-intersecting, sets. Unmarked tests are in the \"default\" silo.</p> <p>For example we can create an <code>envid</code> marker defining the python environment on which a test runs. Tests that have this marker should run only if <code>pytest</code> is called with a <code>--envid</code> flag indicating that the environment is active. Tests that do not have this marker are considered in the \"default\" environment and should only run when no environment is set.</p> <ul> <li><code>conftest.py</code>:</li> </ul> <pre><code>from pytest_pilot import EasyMarker\n\nenvid = EasyMarker('envid', mode='silos')\n</code></pre> <ul> <li><code>test_silos.py</code> (you'll have to create an <code>__init__.py</code> in the folder to allow for relative imports):</li> </ul> <pre><code>from .conftest import envid\n\n@envid('a')\ndef test_foo_a():\n    pass\n\n@envid('b')\ndef test_foo_b():\n    pass\n\ndef test_foo():\n    pass\n\n@envid.agnostic\ndef test_bar():\n    pass\n</code></pre> <p>Running <code>pytest</code> (with the <code>-rs</code> option to show a summary of skipped tests, and with the new  --pilot-skip flag) yields:</p> <pre><code>&gt;&gt;&gt; pytest -rs --pilot-skip\n============================= test session starts ==========================================\n(...)\ncollected 4 items\n\npytest_pilot/test_doc/test_silos.py::test_foo_a SKIPPED       [ 25%]\npytest_pilot/test_doc/test_silos.py::test_foo_b SKIPPED       [ 50%]\npytest_pilot/test_doc/test_silos.py::test_foo PASSED          [ 75%]\npytest_pilot/test_doc/test_silos.py::test_bar PASSED          [100%]\n\n========================== short test summary info =========================================\nSKIPPED [1] &lt;file&gt;: This test requires 'envid'='a'. Run `pytest --envid=a` to activate it.\nSKIPPED [1] &lt;file&gt;: This test requires 'envid'='b'. Run `pytest --envid=b` to activate it.\n========================== 2 passed, 2 skipped in 0.04s ====================================\n</code></pre> <p>And we can instead activate environment <code>'b'</code>.</p> <pre><code>&gt;&gt;&gt; pytest -rs --pilot-skip --envid=b\n============================= test session starts ==========================================\n(...)\ncollected 4 items\n\npytest_pilot/test_doc/test_silos.py::test_foo_a SKIPPED        [ 25%]\npytest_pilot/test_doc/test_silos.py::test_foo_b PASSED         [ 50%]\npytest_pilot/test_doc/test_silos.py::test_foo SKIPPED          [ 75%]\npytest_pilot/test_doc/test_silos.py::test_bar PASSED           [100%]\n\n========================== short test summary info =============================================================\nSKIPPED [1] &lt;file&gt;: This test requires 'envid'='a'. Currently `--envid=b` so it is skipped.\nSKIPPED [1] &lt;file&gt;: This test does not have mark 'envid', and pytest was run with `--envid=b` so it is skipped\n========================== 2 passed, 2 skipped in 0.04s ========================================================\n</code></pre> <p>Note that as can be seen above, <code>test_foo</code>, that was not marked, is now skipped (it is implicitly in the \"no env\" silo so if we activate another silo it becomes skipped). Only tests explicitly marked as agnostic (in this example <code>test_bar</code>) are allowed to run whatever the silo. This is the main difference with the \"extender\" mode below.</p>"},{"location":"#extender","title":"Extender","text":"<p>The extender mode is probably the simplest to understand: marked tests are optional tests, that can be added to the other tests when the option is specified. For example let's mark a few tests as being slow tests that should be skipped for daily testing. Note that this time we'll create a marker with no arguments to show that such markers can also be created, but it could of course receive arguments just as in previous example.</p> <ul> <li><code>conftest.py</code>:</li> </ul> <pre><code>from pytest_pilot import EasyMarker\n\nslow = EasyMarker('slow', has_arg=False, mode='extender')\n</code></pre> <ul> <li><code>test_extender.py</code>:</li> </ul> <pre><code>from .conftest import slow\n\n@slow\ndef test_bar_slow():\n    pass\n\ndef test_bar():\n    pass\n</code></pre> <p>Running <code>pytest</code> (with the <code>-rs</code> option to show a summary of skipped tests, and with the new  --pilot-skip flag) yields:</p> <pre><code>&gt;&gt;&gt; pytest -rs --pilot-skip\n============================= test session starts ==========================================\n(...)\ncollected 2 items\n\npytest_pilot/test_doc/test_extender.py::test_bar_slow SKIPPED       [ 50%]\npytest_pilot/test_doc/test_extender.py::test_foo PASSED             [100%]\n\n========================== short test summary info =========================================\nSKIPPED [1] &lt;file&gt;: This test requires 'slow'. Run `pytest --slow` to activate it.\n========================== 1 passed, 1 skipped in 0.04s ====================================\n</code></pre> <p>And we can run all tests including the slow ones with <code>--slow</code>:</p> <pre><code>&gt;&gt;&gt; pytest -rs --pilot-skip --slow\n============================= test session starts ==========================================\n(...)\ncollected 2 items\n\npytest_pilot/test_doc/test_extender.py::test_bar_slow PASSED        [ 50%]\npytest_pilot/test_doc/test_extender.py::test_foo PASSED             [100%]\n\n================================ 2 passed in 0.04s =========================================\n</code></pre>"},{"location":"#hard-filter","title":"Hard filter","text":"<p>\"Hard filter\" mode is the opposite of \"Extender\". Instead of adding tests when the option is active, it removes all irrelevant tests, keeping only those matching the query.</p> <ul> <li><code>conftest.py</code>:</li> </ul> <pre><code>from pytest_pilot import EasyMarker\n\n# below we demonstrate the usage of `allowed_values` to restrict the possible values\nflavour = EasyMarker('flavour', allowed_values=('red', 'yellow'), mode='hard_filter')\n</code></pre> <ul> <li><code>test_hardfilter.py</code> (you'll have to create an <code>__init__.py</code> in the folder to allow for relative imports):</li> </ul> <pre><code>from .conftest import flavour\n\n@flavour('yellow')\ndef test_foo_yellow():\n    pass\n\n@flavour('red')\ndef test_foo_red():\n    pass\n\ndef test_foo():\n    pass\n\n@flavour.agnostic\ndef test_bar():\n    pass\n</code></pre> <p>Running <code>pytest</code> (with the <code>-rs</code> option to show a summary of skipped tests, and with the new  --pilot-skip flag) yields:</p> <pre><code>&gt;&gt;&gt; pytest -rs --pilot-skip\n============================= test session starts ==========================================\n(...)\ncollected 4 items                                                                                                                                                                                                   \npytest_pilot/test_doc/test_hardfilter.py::test_foo_yellow PASSED         [ 25%]\npytest_pilot/test_doc/test_hardfilter.py::test_foo_red PASSED            [ 50%]\npytest_pilot/test_doc/test_hardfilter.py::test_foo PASSED                [ 75%]\npytest_pilot/test_doc/test_hardfilter.py::test_bar PASSED                [100%]\n\n================================ 4 passed in 0.04s =========================================\n</code></pre> <p>We can instead filter on tests with the <code>'red'</code> flavour:</p> <pre><code>&gt;&gt;&gt; pytest -rs --pilot-skip --flavour=red\n============================= test session starts ==========================================\n(...)\ncollected 4 items\n\npytest_pilot/test_doc/test_hardfilter.py::test_foo_yellow SKIPPED         [ 25%]\npytest_pilot/test_doc/test_hardfilter.py::test_foo_red PASSED             [ 50%]\npytest_pilot/test_doc/test_hardfilter.py::test_foo SKIPPED                [ 75%]\npytest_pilot/test_doc/test_hardfilter.py::test_bar PASSED                 [100%]\n\n========================== short test summary info =============================================================\nSKIPPED [1] &lt;file&gt;: This test requires 'flavour'='yellow'. Currently `--flavour=red` so it is skipped.\nSKIPPED [1] &lt;file&gt;: This test does not have mark 'flavour', and pytest was run with `--flavour=red` so it is skipped.\n========================== 2 passed, 2 skipped in 0.04s ========================================================\n</code></pre> <p>You can see that <code>test_foo</code>, that was not marked, has been skipped, while <code>test_bar</code>, that was explicitly marked as <code>agnostic</code>, continues to run. This is the main difference with the soft filer presented below.</p>"},{"location":"#soft-filter","title":"Soft filter","text":"<p>\"Soft filter\" mode is very similar to \"Hard filter\". The only difference is for non-marked tests. While in hard filter mode they are skipped as soon as the option is active, in soft filter mode they are always run.</p> <ul> <li><code>conftest.py</code>:</li> </ul> <pre><code>from pytest_pilot import EasyMarker\n\nflavour = EasyMarker('flavour', allowed_values=('red', 'yellow'), mode='soft_filter')\n</code></pre> <ul> <li><code>test_hardfilter.py</code> (you'll have to create an <code>__init__.py</code> in the folder to allow for relative imports):</li> </ul> <pre><code>from .conftest import flavour\n\n@flavour('yellow')\ndef test_foo_yellow():\n    pass\n\n@flavour('red')\ndef test_foo_red():\n    pass\n\ndef test_foo():\n    pass\n</code></pre> <p>Running <code>pytest</code> (with the <code>-rs</code> option to show a summary of skipped tests, and with the new  --pilot-skip flag) yields:</p> <pre><code>&gt;&gt;&gt; pytest -rs --pilot-skip\n============================= test session starts ==========================================\n(...)\ncollected 3 items                                                                                                                                                                                                   \npytest_pilot/test_doc/test_hardfilter.py::test_foo_yellow PASSED         [ 33%]\npytest_pilot/test_doc/test_hardfilter.py::test_foo_red PASSED            [ 66%]\npytest_pilot/test_doc/test_hardfilter.py::test_foo PASSED                [100%]\n\n================================ 3 passed in 0.04s =========================================\n</code></pre> <p>We can instead filter on tests with the <code>'yellow'</code> flavour:</p> <pre><code>&gt;&gt;&gt; pytest -rs --pilot-skip --flavour=yellow\n============================= test session starts ==========================================\n(...)\ncollected 3 items\n\npytest_pilot/test_doc/test_hardfilter.py::test_foo_yellow PASSED           [ 33%]\npytest_pilot/test_doc/test_hardfilter.py::test_foo_red SKIPPED             [ 66%]\npytest_pilot/test_doc/test_hardfilter.py::test_foo PASSED                  [100%]\n\n========================== short test summary info =============================================================\nSKIPPED [1] &lt;file&gt;: This test requires 'flavour'='red'. Currently `--flavour=yellow` so it is skipped.\n========================== 2 passed, 1 skipped in 0.04s ========================================================\n</code></pre> <p>You can see that now <code>test_foo</code>, that was not marked, was not skipped - as opposed to the previous example of \"hard filter\".</p>"},{"location":"#7-misc","title":"7. Misc","text":""},{"location":"#deselecting-or-skipping","title":"Deselecting or skipping","text":"<p>By default starting in version <code>0.9.0</code>, tests that should not run because of a given combination of markers and  commandline options are simply deselected. This is much faster on large test codebases than marking tests as skipped.</p> <p>The legacy mode where tests that should not run appear as \"skipped\" can be enabled with the new <code>--pilot-skip</code>  commandline option as shown above.</p>"},{"location":"#knowing-the-value-of-the-command-options-inside-a-test","title":"Knowing the value of the command options inside a test","text":"<p>There are two ways to know the value of an option associated to a marker, from within a test.</p> <ul> <li> <p>either you can use the usual <code>pytest</code> API to get the <code>config</code> object, and from there do <code>config.getoption(&lt;marker_option_name&gt;)</code> where you can programmatically fill <code>&lt;marker_option_name&gt;</code> from <code>marker.cmdoption_long[2:]</code>.</p> </li> <li> <p>or you can simply use the <code>easymarkers</code> fixture. This object has one attribute per <code>EasyMarker</code> and the attribute values correspond to the corresponding commandline option value:</p> </li> </ul> <pre><code>def test_foo(easymarkers):\n    # see the value of all marker related options at once\n    print(easymarkers)\n    # see the value of the --envid option\n    print(easymarkers.envid)\n</code></pre>"},{"location":"#using-the-markers-in-parametrized-tests","title":"Using the markers in parametrized tests","text":"<p>If your tests are parametrized, you can use the markers on individual parametrization value:</p> <ul> <li>either using the traditional <code>pytest.param(&lt;argvalues&gt;, marks=&lt;marker&gt;)</code></li> <li>either using the provided convenience method <code>&lt;marker&gt;.param(&lt;argvalues&gt;)</code></li> </ul> <p>As shown below: </p> <pre><code>@pytest.mark.parametrize(\"a\", [\n    pytest.param(-1, marks=slow),\n    0, \n    pytest.param(False, marks=envid(\"win\")),\n    slow.param(True), \n    1,\n    envid(\"win\").param(2)\n])\ndef test_foo(a):\n    pass\n</code></pre>"},{"location":"#further-customization","title":"Further customization","text":"<p>See API reference for details.</p>"},{"location":"#debug-verbosity-levels","title":"Debug / Verbosity levels","text":"<p>You can use the verbose pytest flags with the <code>-s</code> option to get a little more explanation about why tests are skipped or why they are NOT skipped (while you think they should):</p> <pre><code>&gt;&gt;&gt; pytest -s -vv --flavour=red\n(verbose explanations)\n&gt;&gt;&gt; pytest -s -vvv --flavour=red\n(even more verbose explanations)\n</code></pre>"},{"location":"#help","title":"Help","text":"<p>Help on command options is automatically added to the <code>pytest --help</code> output:</p> <pre><code>&gt;&gt;&gt; pytest --help\n\n(...)\n\ncustom options:\n  --flavour=NAME        run tests marked as requiring flavour NAME (marked with @flavour(NAME)), as well as tests not marked with @flavour. If you call `pytest` without this option, tests marked with @flavour will *all* be run.\n\n(...)\n</code></pre> <p>Help on markers is automatically added to the <code>pytest --markers</code> output:</p> <pre><code>&gt;&gt;&gt; pytest --markers\n\n(...)\n\n@pytest.mark.flavour(value): mark test to run *both* when --flavour ('flavour' option) is set to &lt;value&gt; and if --flavour is not set. &lt;value&gt; should be one of ('red', 'yellow').\n\n(...)\n</code></pre>"},{"location":"#main-features-benefits","title":"Main features / benefits","text":"<ul> <li>Create intuitive markers in minutes, with consistent behaviour and associated command options, documented with user-friendly help.</li> </ul>"},{"location":"#see-also","title":"See Also","text":"<ul> <li>pytest tutorial on working with custom markers</li> <li>this excellent explanation about how to add options so as to filter on custom markers or on parameter names and values</li> <li>pytest hooks</li> </ul>"},{"location":"#others","title":"Others","text":"<p>Do you like this library ? You might also like my other python libraries </p>"},{"location":"#want-to-contribute","title":"Want to contribute ?","text":"<p>Details on the github page: https://github.com/smarie/python-pytest-pilot</p>"},{"location":"api_reference/","title":"API reference","text":"<p>In general, using <code>help(symbol)</code> is the recommended way to get the latest documentation. In addition, this page provides an overview of the various elements in this package.</p>"},{"location":"api_reference/#easymarker","title":"<code>EasyMarker</code>","text":"<p>A helper class to create pytest marks.</p> <pre><code>EasyMarker(marker_id,             # type: str\n           mode,                  # type: str\n           full_name=None,        # type: str\n           has_arg=True,          # type: bool\n           allowed_values=None,   # type: Iterable[Any]\n           cmdoption_short=None,  # type: str\n           cmdoption_long=None,   # type: str\n           cmdhelp=None,          # type: str\n           markhelp=None,         # type: str\n           )\n</code></pre> <p>Creates a pair of marker + commandline option for pytest. Marker instances can be used</p> <ul> <li>to decorate test classes or test functions: @marker or @marker(arg) depending whether you set has_arg=False/True</li> <li>in parametrization values with <code>pytest.param(*&lt;argvalues&gt;, marks=&lt;self&gt;)</code> or   <code>pytest.param(*&lt;argvalues&gt;, marks=&lt;self&gt;(arg))</code> (for this, we inherit from MarkDecorator and override .mark) <p>In addition, <code>&lt;self&gt;.param(*&lt;argvalues&gt;)</code> or <code>&lt;self&gt;(arg).param(*&lt;argvalues&gt;)</code> is a convenience method provided to do the same than <code>pytest.param(*&lt;argvalues&gt;, marks=&lt;self&gt;)</code> or <code>pytest.param(*&lt;argvalues&gt;, marks=&lt;self&gt;(arg))</code>.</p> <p>A special decorator <code>@&lt;marker&gt;.agnostic</code> can be used to decorate tests that should always run, whatever the configuration.  This is only relevant for <code>mode='silos'</code> or <code>mode='hard_filter'</code>, see below.</p> <p>Parameters:</p> <ul> <li><code>marker_id</code>: the name of the pytest mark. Applying this marker with <code>@marker(arg)</code> will be equivalent to applying @pytest.mark.(arg) <li> <p><code>mode</code>: a mandatory string indicating the working mode of this mark and the associated filter option. Four modes are supported:</p> <ul> <li>'silos': When the option is inactive, only non-marked tests are run. When the option is active, only relevant marked tests run. There is no test in common between these \"silos\"</li> <li>'extender': When the option is inactive, only non-marked tests are run, this is the \"base\" set of tests. When the option is active, it adds the relevant marked tests to the base set.</li> <li>'hard_filter': When the option is inactive, all tests run. When the option is active, only the relevant marked tests run.</li> <li>'soft_filter': When the option is inactive, all tests run. When the option is active, all non-marked tests continue to run, but among marked tests only the relevant ones run.</li> </ul> </li> <li> <p><code>full_name</code>: the full name of the marker, to be used in help texts. If <code>None</code> (default), it defaults to <code>marker_id</code>.</p> </li> <li><code>has_arg</code>: if this is <code>True</code> (default), the marker has a single argument and the filtering commandline option accepts an argument too. For example a <code>colormarker</code> with id <code>color</code> will accept an argument describing which color: <code>@colormarker('yellow')</code>. If this is <code>False</code>, the marker has no argument and the filtering commandline option is a flag with no arguments too. For example a <code>smokemarker</code> with id <code>smoke</code>: <code>@smokemarker</code>.</li> <li><code>allowed_values</code>: a predefined set of values that can be used for this marker. Applying the mark with another value as argument will result in a <code>ValueError</code>being raised. <code>None</code> (default) will allow users to apply this mark with any value. Note that this can only be set if <code>has_arg</code>is <code>True</code></li> <li><code>cmdoption_short</code>: the id to use for the \"short\" command option (for example providing <code>'E'</code> or <code>'-E'</code> will result in  the option <code>'-E'</code>). <code>None</code> (default) will not create a \"short\" command option, to avoid name collisions.</li> <li><code>cmdoption_long</code>: the id to use for the \"long\" command option (for example providing <code>'env'</code> or <code>'--env'</code> will result in the option <code>'--env'</code>). <code>None</code> (default) will use <code>marker_id</code> for the long command option.</li> <li><code>cmdhelp</code>: the help message displayed when <code>pytest --help</code> is called</li> <li><code>markhelp</code>: the help message displayed when <code>pytest --markers</code> is called</li>"},{"location":"api_reference/#easymarkers-fixture","title":"<code>easymarkers</code> fixture","text":"<p>A fixture containing all EasyMarker related CLI option current values</p> <p>You can list all key-value pairs with <code>vars(easymarkers)</code> and access each value using attribute access: <code>easymarkers.&lt;option&gt;</code>.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#090-tests-are-deselected-by-cli-options-by-default","title":"0.9.0 - Tests are deselected by CLI options by default","text":"<ul> <li>Breaking change the plugin now by default deselects all tests that were usually skipped by marker CLI config.     New <code>--pilot-skip</code> flag option can be used to enable the legacy behaviour where tests where marked as skipped     instead. Fixes #20</li> </ul>"},{"location":"changelog/#080-new-easymarkers-fixture","title":"0.8.0 - New <code>easymarkers</code> fixture","text":"<ul> <li>New <code>easymarkers</code> fixture to access current values of all CLI options related to EasyMarkers, from within tests. Fixed #17</li> </ul>"},{"location":"changelog/#070-new-agnostic-mark","title":"0.7.0 - New <code>agnostic</code> mark","text":"<ul> <li><code>@&lt;marker&gt;.agnostic</code> can be used to decorate tests that should always run, whatever the configuration. This is only relevant for <code>mode='silos'</code> or <code>mode='hard_filter'</code>. Fixes #15</li> </ul>"},{"location":"changelog/#060-usage-in-parametrization","title":"0.6.0 - Usage in parametrization","text":"<ul> <li><code>EasyMarker</code> markers can now be used on parameters in tests (and also on case functions, if you use <code>pytest-cases</code> :)). Fixes #12</li> </ul>"},{"location":"changelog/#050-better-api-implementation-and-documentation","title":"0.5.0 - Better API, implementation and documentation","text":"<ul> <li><code>EasyMarker</code> API improvements: now a single <code>mode</code> argument with four supported values (<code>'silos'</code>, <code>'extender'</code>, <code>hard_filter</code>, <code>soft_filter</code>) replaces the very unfriendly <code>filtering_skips_unmarked</code> and <code>not_filtering_skips_marked</code>. This argument is mandatory, so that users have to decide what they want as a resulting behaviour. Fixes #5</li> <li>Markers without arguments (<code>EasyMarker(has_arg=False)</code>) now work correctly. Fixes #8</li> <li>Short command option name (<code>EasyMarker(cmdoption_short=...)</code>) is now registered correctly. Fixed #9</li> <li><code>allowed_values</code> are now correctly taken into account by <code>EasyMarker</code>. Fixes #1 </li> <li>Removed annoying warning about marks registration. Fixes #6</li> <li>Improved the various messages printed when using <code>pytest --markers</code> and <code>pytest --help</code>. In particular, using <code>--markers</code> shows the allowed values for a given marker.</li> </ul>"},{"location":"changelog/#012-packaging-improvements","title":"0.1.2 - packaging improvements","text":"<ul> <li>packaging improvements: set the \"universal wheel\" flag to 1, and cleaned up the <code>setup.py</code>. In particular removed dependency to <code>six</code> for setup and added <code>py.typed</code> file, as well as set the <code>zip_safe</code> flag to False. Removed tests folder from package. Fixes #4</li> </ul>"},{"location":"changelog/#011-pyprojecttoml","title":"0.1.1 - <code>pyproject.toml</code>","text":"<p>Added <code>pyproject.toml</code></p>"},{"location":"changelog/#010-first-public-version","title":"0.1.0 - First public version","text":"<ul> <li>Initial fork from private repository</li> </ul>"},{"location":"long_description/","title":"pytest-pilot","text":"<p>Slice in your test base thanks to powerful markers</p> <p>The documentation for users is available here: https://smarie.github.io/python-pytest-pilot/</p> <p>A readme for developers is available here: https://github.com/smarie/python-pytest-pilot</p>"}]}